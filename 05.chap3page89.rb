# The number of steps an algorithm makes can vary. For example, based on the size of the array if you are doing binary search.

# Big O Notation allows us to categorize the efficiency of a given algorithm.

# Big O achieves consistency by focusing on the number of steps that an algorithm takes

# For example, linear search will take as many steps as there are elements in the array. For N elements in the array, linear search can take up to N steps.

# If there are N data elements, how many steps will the algorithm take?
# O(N) means it will take as many steps as there are elements.

# An algorithm that is O(N) is known as having linear time.

# How many steps does it take to read data from an Array? Just one step. O(1).

# IF THERE ARE N ELEMENTS, HOW MANY STEPS WILL THE ALGORITHM TAKE?

# What Big O is truly concerned about is: how will an algorithm's performance change as the data increases?

# Big O generally refers to worst case scenario unless specified otherwise.

# Binary search has a time complexity of O(log N)

# O(log N) is the Big O way of describing an algorithm that increases one step each time the data is doubled.

